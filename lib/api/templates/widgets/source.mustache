#include "{{{ dartname }}}.hpp"

namespace fldart {
FunctionMapping {{{ dartname }}}::methods[] = {
  {{# constructors }}
  {"fldart::{{{ dartname }}}::create{{{ dartname }}}{{{ name }}}", {{{ dartname }}}::create{{{ dartname }}}{{{ name }}}},
  {{/ constructors }}
  {{# methods }}
  {"fldart::{{{ dartname }}}::{{{ name }}}", {{{ dartname }}}::{{{ name }}}},
  {{/ methods }}
  {NULL, NULL}
};
{{# constructors }}

void {{{ dartname }}}::create{{{ dartname }}}{{{ name }}}(Dart_NativeArguments arguments) {
  {{{ cname }}}* instance;
  {{# args }}
  {{{ type }}} {{{ name }}};
  {{/ args }}

  Dart_EnterScope();

  // Resolve variables.
  {{# args }}
  HandleError({{{ conv }}}(HandleError(Dart_GetNativeArgument(arguments, {{{ argi }}})), &{{{ name }}}));
  {{/ args }}

  instance = new {{{ cname }}}({{{ pass }}});

  Dart_Handle result = Dart_NewInteger((int64_t)instance);
  Dart_SetReturnValue(arguments, result);
  Dart_ExitScope();
}
{{/ constructors }}
{{# methods }}

void {{{ dartname }}}::{{{ name }}}(Dart_NativeArguments arguments) {
  // Local variables
  int64_t ptr;
  {{ cname }}* ref;
  {{# args }}
  {{{ type }}} {{{ name }}};
  {{/ args }}

  Dart_EnterScope();

  // Resolve reference.
  HandleError(Dart_IntegerToInt64(HandleError(Dart_GetNativeArgument(arguments, 0)), &ptr));
  ref = ({{ cname }}*)ptr;

  // Resolve other variables.
  {{# args }}
  HandleError({{{ conv }}}(HandleError(Dart_GetNativeArgument(arguments, {{{ argi }}})), &{{{ name }}}));
  {{/ args }}

  // Execute this method.
  {{{ temp }}}ref -> {{{ name }}}({{{ pass }}});

  // Resolve return value,
  Dart_Handle result = {{{ retf }}};
  Dart_SetReturnValue(arguments, result);

  Dart_ExitScope();
}
{{/ methods }}
}
